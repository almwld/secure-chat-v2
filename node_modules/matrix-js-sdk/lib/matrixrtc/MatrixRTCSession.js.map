{"version":3,"file":"MatrixRTCSession.js","names":["logger","rootLogger","TypedEventEmitter","EventTimeline","EventType","RelationType","KnownMembership","CallMembership","RoomStateEvent","MembershipManager","StickyEventMembershipManager","EncryptionManager","logDurationSync","MembershipManagerEvent","RTCEncryptionManager","ToDeviceKeyTransport","TypedReEmitter","RoomStickyEventsEvent","RoomKeyTransport","MatrixRTCSessionEvent","slotIdToDescription","slotId","application","id","split","slotDescriptionToId","slotDescription","concat","DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS","listenForStickyEvents","listenForMemberStateEvents","MatrixRTCSession","membershipStatus","_this$membershipManag","membershipManager","status","probablyLeft","_this$membershipManag2","delayId","_this$membershipManag3","callId","_this$slotDescription","sessionMembershipsForSlot","room","_arguments","arguments","_asyncToGenerator","options","length","undefined","getChild","roomId","callMemberEvents","collectMembersEvents","callMemberships","computeBackendIdentityAndVerifyMemberEvents","sort","a","b","createdTs","debug","map","m","userId","sessionForSlot","client","opts","roomSubset","constructor","calculateMembershipsOpts","_this","this","_defineProperty","counters","roomEventEncryptionKeysSent","roomEventEncryptionKeysReceived","totals","roomEventEncryptionKeysReceivedTotalAge","ensureRecalculateSessionMembers","added","updated","removed","flatMap","v","current","previous","some","e","getType","RTCMembership","recalculateSessionMembers","_this$encryptionManag","oldMemberships","memberships","changed","i","equal","_this$membershipManag4","_this$membershipManag5","info","emit","MembershipsChanged","onRTCSessionMemberUpdate","ownMembership","pendingNotificationToSend","_this$joinConfig","eventId","joinConfig","notificationType","sendCallNotify","callIntent","warn","encryptionManager","onMembershipsUpdate","setExpiryTimer","on","Members","onRoomMemberUpdate","Update","onStickyEventUpdate","isJoined","_this$membershipManag6","_this$membershipManag7","stop","_this2","_this2$membershipMana","leave","expiryTimeout","clearTimeout","off","joinRTCSession","ownMembershipIdentity","fociPreferred","multiSfuFocus","_this$joinConfig2","unstableSendStickyEvents","memberId","reEmitter","reEmit","ProbablyLeft","StatusChanged","DelayIdChanged","transport","useExperimentalToDeviceTransport","statistics","keyBin","encryptionKeyIndex","membership","rtcBackendIdentity","EncryptionKeyChanged","join","error","MembershipManagerError","JoinStateChanged","joinRoomSession","deviceId","getUserId","getDeviceId","leaveRoomSession","_arguments2","_this3","timeout","leavePromise","getFocusInUse","oldestMembership","getOldestMembership","getTransport","getActiveFocus","_this$getOldestMember","getFocusActive","getConsensusCallIntent","_this$memberships$fin","getFirstCallIntent","find","every","updateCallIntent","_this4","_this4$membershipMana","_this4$membershipMana2","myMembership","Error","reemitEncryptionKeys","_this$encryptionManag2","getEncryptionKeys","forEach","keyRing","key","keyInfo","keyIndex","soonestExpiry","thisExpiry","getMsUntilExpiry","setTimeout","bind","parentEventId","_this5","sendNotificationEvent","_ref3","content","user_ids","event_id","rel_type","Reference","Date","now","response","sendEvent","RTCNotification","apply","then","notification","newResult","_objectSpread","DidSendCallNotification","catch","_ref4","errorLegacy","errorNew","recalculateSessionMembersPromise","recalculateSessionMembersDirty","_x","_x2","_x3","_x4","_computeBackendIdentityAndVerifyMemberEvents","memberEvent","getContent","quickFilterNonRelevantContents","membershipData","membershipDataFromMatrixEvent","computeRtcBackendIdentity","isValidMembership","push","eventKeysCount","Object","keys","filter","k","_membership$userId","JSON","stringify","isExpired","hasMembershipState","Join","_unstable_getStickyEvents","roomState","getLiveTimeline","getState","FORWARDS","callMemberStateEvents","getStateEvents","GroupCallMemberPrefix","callMemberStateEvent","stickyEvent","msc4354_sticky_key","getStateKey"],"sources":["../../src/matrixrtc/MatrixRTCSession.ts"],"sourcesContent":["/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { EventType, RelationType } from \"../@types/event.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { type ISendEventResponse } from \"../@types/requests.ts\";\nimport { CallMembership } from \"./CallMembership.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { MembershipManager, StickyEventMembershipManager } from \"./MembershipManager.ts\";\nimport { type CallMembershipIdentityParts, EncryptionManager, type IEncryptionManager } from \"./EncryptionManager.ts\";\nimport { logDurationSync } from \"../utils.ts\";\nimport type {\n    Statistics,\n    RTCNotificationType,\n    Status,\n    IRTCNotificationContent,\n    RTCCallIntent,\n    Transport,\n} from \"./types.ts\";\nimport {\n    MembershipManagerEvent,\n    type MembershipManagerEventHandlerMap,\n    type IMembershipManager,\n} from \"./IMembershipManager.ts\";\nimport { RTCEncryptionManager } from \"./RTCEncryptionManager.ts\";\nimport { ToDeviceKeyTransport } from \"./ToDeviceKeyTransport.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { type IContent, type MatrixEvent } from \"../models/event.ts\";\nimport { RoomStickyEventsEvent, type RoomStickyEventsMap } from \"../models/room-sticky-events.ts\";\nimport { RoomKeyTransport } from \"./RoomKeyTransport.ts\";\n\n/**\n * Events emitted by MatrixRTCSession\n */\nexport enum MatrixRTCSessionEvent {\n    // A member joined, left, or updated a property of their membership.\n    MembershipsChanged = \"memberships_changed\",\n    // We joined or left the session: our own local idea of whether we are joined,\n    // separate from MembershipsChanged, ie. independent of whether our member event\n    // has successfully gone through.\n    JoinStateChanged = \"join_state_changed\",\n    // The key used to encrypt media has changed\n    EncryptionKeyChanged = \"encryption_key_changed\",\n    /** The membership manager had to shut down caused by an unrecoverable error */\n    MembershipManagerError = \"membership_manager_error\",\n    /** The RTCSession did send a call notification caused by joining the call as the first member */\n    DidSendCallNotification = \"did_send_call_notification\",\n}\n\nexport type MatrixRTCSessionEventHandlerMap = {\n    [MatrixRTCSessionEvent.MembershipsChanged]: (\n        oldMemberships: CallMembership[],\n        newMemberships: CallMembership[],\n    ) => void;\n    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;\n    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (\n        key: Uint8Array<ArrayBuffer>,\n        encryptionKeyIndex: number,\n        membership: CallMembershipIdentityParts,\n        rtcBackendIdentity: string,\n    ) => void;\n    [MatrixRTCSessionEvent.MembershipManagerError]: (error: unknown) => void;\n    [MatrixRTCSessionEvent.DidSendCallNotification]: (\n        notificationContentNew: { event_id: string } & IRTCNotificationContent,\n    ) => void;\n};\n\nexport interface SessionConfig {\n    /**\n     * What kind of notification to send when starting the session.\n     * @default `undefined` (no notification)\n     */\n    notificationType?: RTCNotificationType;\n\n    /**\n     * Determines the kind of call this will be.\n     */\n    callIntent?: RTCCallIntent;\n}\n\n/**\n * The session description is used to identify a session. Used in the state event.\n */\nexport interface SlotDescription {\n    id: string;\n    application: string;\n}\nexport function slotIdToDescription(slotId: string): SlotDescription {\n    const [application, id] = slotId.split(\"#\");\n    return { application, id };\n}\nexport function slotDescriptionToId(slotDescription: SlotDescription): string {\n    return `${slotDescription.application}#${slotDescription.id}`;\n}\n\n// The names follow these principles:\n// - we use the technical term delay if the option is related to delayed events.\n// - we use delayedLeaveEvent if the option is related to the delayed leave event.\n// - we use membershipEvent if the option is related to the rtc member state event.\n// - we use the technical term expiry if the option is related to the expiry field of the membership state event.\n// - we use a `Ms` postfix if the option is a duration to avoid using words like:\n//   `time`, `duration`, `delay`, `timeout`... that might be mistaken/confused with technical terms.\nexport interface MembershipConfig {\n    /**\n     * The timeout (in milliseconds) after we joined the call, that our membership should expire\n     * unless we have explicitly updated it.\n     *\n     * This is what goes into the m.rtc.member event expiry field and is typically set to a number of hours.\n     */\n    membershipEventExpiryMs?: number;\n\n    /**\n     * The time in (in milliseconds) which the manager will prematurely send the updated state event before the membership `expires` time to make sure it\n     * sends the updated state event early enough.\n     *\n     * A headroom of 1000ms and a `membershipExpiryTimeout` of 10000ms would result in the first membership event update after 9s and\n     * a membership event that would be considered expired after 10s.\n     *\n     * This value does not have an effect on the value of `SessionMembershipData.expires`.\n     */\n    membershipEventExpiryHeadroomMs?: number;\n\n    /**\n     * The timeout (in milliseconds) with which the deleayed leave event on the server is configured.\n     * After this time the server will set the event to the disconnected stat if it has not received a keep-alive from the client.\n     */\n    delayedLeaveEventDelayMs?: number;\n\n    /**\n     * The interval (in milliseconds) in which the client will send membership keep-alives to the server.\n     */\n    delayedLeaveEventRestartMs?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a server rate limit has been hit.\n     */\n    maximumRateLimitRetryCount?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a network error occurs.\n     */\n    maximumNetworkErrorRetryCount?: number;\n\n    /**\n     * The time (in milliseconds) after which we will retry a http request if it\n     * failed to send due to a network error. (send membership event, send delayed event, restart delayed event...)\n     */\n    networkErrorRetryMs?: number;\n\n    /**\n     * If true, use the new to-device transport for sending encryption keys.\n     */\n    useExperimentalToDeviceTransport?: boolean;\n\n    /**\n     * The time (in milliseconds) after which a we consider a delayed event restart http request to have failed.\n     * Setting this to a lower value will result in more frequent retries but also a higher chance of failiour.\n     *\n     * In the presence of network packet loss (hurting TCP connections), the custom delayedEventRestartLocalTimeoutMs\n     * helps by keeping more delayed event reset candidates in flight,\n     * improving the chances of a successful reset. (its is equivalent to the js-sdk `localTimeout` configuration,\n     * but only applies to calls to the `_unstable_restartScheduledDelayedEvent` endpoint\n     * or the `_unstable_updateDelayedEvent` endpoint with a body of `{action:\"restart\"}`.)\n     */\n    delayedLeaveEventRestartLocalTimeoutMs?: number;\n\n    /**\n     * Send membership using sticky events rather than state events.\n     * This also make the client use the new m.rtc.member MSC4354 event format. (instead of m.call.member)\n     *\n     * **WARNING**: This is an unstable feature and not all clients will support it.\n     */\n    unstableSendStickyEvents?: boolean;\n}\n\nexport interface EncryptionConfig {\n    /**\n     *  If true, generate and share a media key for this participant,\n     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when\n     *  media keys for other participants become available.\n     */\n    manageMediaKeys?: boolean;\n    /**\n     * The minimum time (in milliseconds) between each attempt to send encryption key(s).\n     * e.g. if this is set to 1000, then we will send at most one key event every second.\n     * @deprecated - Not used by the new encryption manager.\n     */\n    updateEncryptionKeyThrottle?: number;\n\n    /**\n     * Sometimes it is necessary to rotate the encryption key after a membership update.\n     * For performance reasons we might not want to rotate the key immediately but allow future memberships to use the same key.\n     * If 5 people join in a row in less than 5 seconds, we don't want to rotate the key for each of them.\n     * If 5 people leave in a row in less than 5 seconds, we don't want to rotate the key for each of them.\n     * So we do share the key which was already used live for <5s to new joiners.\n     * This does result in a potential leak up to the configured time of call media.\n     * This has to be considered when choosing a value for this property.\n     */\n    keyRotationGracePeriodMs?: number;\n\n    /**\n     * The delay (in milliseconds) after a member leaves before we create and publish a new key, because people\n     * tend to leave calls at the same time.\n     * @deprecated - Not used by the new encryption manager.\n     */\n    makeKeyDelay?: number;\n    /**\n     * The delay (in milliseconds) between sending a new key and starting to encrypt with it. This\n     * gives others a chance to receive the new key to minimize the chance they get media they can't decrypt.\n     *\n     * The higher this value is, the better it is for existing members as they will have a smoother experience.\n     * But it impacts new joiners: They will always have to wait `useKeyDelay` before being able to decrypt the media\n     * (as it will be encrypted with the new key after the delay only), even if the key has already arrived before the delay.\n     */\n    useKeyDelay?: number;\n}\nexport type JoinSessionConfig = SessionConfig & MembershipConfig & EncryptionConfig;\n\ninterface SessionMembershipsForSlotOpts {\n    /**\n     * Listen for incoming sticky member events. If disabled, this session will\n     * ignore any incoming sticky events.\n     */\n    listenForStickyEvents: boolean;\n    /**\n     * Listen for incoming  member state events (legacy). If disabled, this session will\n     * ignore any incoming state events.\n     */\n    listenForMemberStateEvents: boolean;\n}\n\nconst DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS: SessionMembershipsForSlotOpts = {\n    listenForStickyEvents: true,\n    listenForMemberStateEvents: true,\n};\n\n/**\n * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.\n * This class doesn't deal with media at all, just membership & properties of a session.\n */\nexport class MatrixRTCSession extends TypedEventEmitter<\n    MatrixRTCSessionEvent | MembershipManagerEvent,\n    MatrixRTCSessionEventHandlerMap & MembershipManagerEventHandlerMap\n> {\n    private membershipManager?: IMembershipManager;\n    private encryptionManager?: IEncryptionManager;\n    private joinConfig?: SessionConfig;\n    private logger: Logger;\n\n    private pendingNotificationToSend: undefined | RTCNotificationType;\n    /**\n     * This timeout is responsible to track any expiration. We need to know when we have to start\n     * to ignore other call members. There is no callback for this. This timeout will always be configured to\n     * emit when the next membership expires.\n     */\n    private expiryTimeout?: ReturnType<typeof setTimeout>;\n\n    public memberships: CallMembership[] = [];\n\n    /**\n     * The statistics for this session.\n     */\n    public statistics: Statistics = {\n        counters: {\n            roomEventEncryptionKeysSent: 0,\n            roomEventEncryptionKeysReceived: 0,\n        },\n        totals: {\n            roomEventEncryptionKeysReceivedTotalAge: 0,\n        },\n    };\n\n    public get membershipStatus(): Status | undefined {\n        return this.membershipManager?.status;\n    }\n    public get probablyLeft(): boolean | undefined {\n        return this.membershipManager?.probablyLeft;\n    }\n    public get delayId(): string | undefined {\n        return this.membershipManager?.delayId;\n    }\n\n    /**\n     * The callId (sessionId) of the call.\n     *\n     * It can be undefined since the callId is only known once the first membership joins.\n     * The callId is the property that, per definition, groups memberships into one call.\n     * @deprecated use `slotId` instead.\n     */\n    public get callId(): string | undefined {\n        return this.slotDescription?.id;\n    }\n    /**\n     * The slotId of the call.\n     * `{application}#{appSpecificId}`\n     * It can be undefined since the slotId is only known once the first membership joins.\n     * The slotId is the property that, per definition, groups memberships into one call.\n     */\n    public get slotId(): string | undefined {\n        return slotDescriptionToId(this.slotDescription);\n    }\n\n    /**\n     * Returns all the call memberships for a room that match the provided `sessionDescription`,\n     * oldest first.\n     *\n     * By default, this will return *both* sticky and member state events.\n     */\n    public static async sessionMembershipsForSlot(\n        room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"hasMembershipState\" | \"_unstable_getStickyEvents\">,\n        slotId: string,\n        // default both true this implied we combine sticky and state events for the final call state\n        // (prefer sticky events in case of a duplicate)\n        options: SessionMembershipsForSlotOpts = DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS,\n    ): Promise<CallMembership[]> {\n        const logger = rootLogger.getChild(`[MatrixRTCSession ${room.roomId}]`);\n        const callMemberEvents = collectMembersEvents(room, options, logger);\n\n        const callMemberships = await computeBackendIdentityAndVerifyMemberEvents(\n            room,\n            callMemberEvents,\n            slotId,\n            logger,\n        );\n\n        callMemberships.sort((a, b) => a.createdTs() - b.createdTs());\n        if (callMemberships.length > 1) {\n            logger.debug(\n                `Call memberships in room ${room.roomId}, in order: `,\n                callMemberships.map((m) => [m.createdTs(), m.userId]),\n            );\n        }\n\n        return callMemberships;\n    }\n\n    /**\n     * Return the MatrixRTC session for the room.\n     * This returned session can be used to find out if there are active sessions\n     * for the requested room and `slotDescription`.\n     */\n    public static sessionForSlot(\n        client: MatrixClient,\n        room: Room,\n        slotDescription: SlotDescription,\n        opts?: SessionMembershipsForSlotOpts,\n    ): MatrixRTCSession {\n        return new MatrixRTCSession(client, room, slotDescription, opts);\n    }\n\n    /**\n     * WARN: this can in theory only be a subset of the room with the properties required by\n     * this class.\n     * Outside of tests this most likely will be a full room, however.\n     * @deprecated Relying on a full Room object being available here is an anti-pattern. You should be tracking\n     * the room object in your own code and passing it in when needed.\n     */\n    public get room(): Room {\n        return this.roomSubset as Room;\n    }\n\n    /**\n     * This constructs a room session. When using MatrixRTC inside the js-sdk this is expected\n     * to be used with the MatrixRTCSessionManager exclusively.\n     *\n     * In cases where you don't use the js-sdk but build on top of another Matrix stack this class can be used standalone\n     * to manage a joined MatrixRTC session.\n     *\n     * @param client A subset of the {@link MatrixClient} that lets the session interact with the Matrix room.\n     * @param roomSubset The room this session is attached to. A subset of a js-sdk Room that the session needs.\n     * @param slotDescription The slot description is a virtual address where participants are allowed to meet.\n     * This session will only manage memberships that match this slot description.Sessions are distinct if any of\n     * those properties are distinct: `roomSubset.roomId`, `slotDescription.application`, `slotDescription.id`.\n     */\n    public constructor(\n        private readonly client: Pick<\n            MatrixClient,\n            | \"getUserId\"\n            | \"getDeviceId\"\n            | \"sendEvent\"\n            | \"sendStateEvent\"\n            | \"_unstable_sendDelayedStateEvent\"\n            | \"_unstable_updateDelayedEvent\"\n            | \"_unstable_cancelScheduledDelayedEvent\"\n            | \"_unstable_restartScheduledDelayedEvent\"\n            | \"_unstable_sendScheduledDelayedEvent\"\n            | \"_unstable_sendStickyEvent\"\n            | \"_unstable_sendStickyDelayedEvent\"\n            | \"cancelPendingEvent\"\n            | \"encryptAndSendToDevice\"\n            | \"off\"\n            | \"on\"\n            | \"decryptEventIfNeeded\"\n        >,\n        private roomSubset: Pick<\n            Room,\n            \"getLiveTimeline\" | \"roomId\" | \"getVersion\" | \"hasMembershipState\" | \"on\" | \"off\"\n        >,\n\n        public readonly slotDescription: SlotDescription,\n        private readonly calculateMembershipsOpts?: SessionMembershipsForSlotOpts,\n    ) {\n        super();\n        this.logger = rootLogger.getChild(`[MatrixRTCSession ${roomSubset.roomId}]`);\n\n        this.roomSubset.on(RoomStateEvent.Members, this.onRoomMemberUpdate);\n        this.roomSubset.on(RoomStickyEventsEvent.Update, this.onStickyEventUpdate);\n\n        // We can ignore this promise because `recalculateSessionMembers` will emit\n        // `MatrixRTCSessionEvent.MembershipsChanged` once it has completed.\n        this.ensureRecalculateSessionMembers();\n        this.setExpiryTimer();\n    }\n    /*\n     * Returns true if we intend to be participating in the MatrixRTC session.\n     * This is determined by checking if the relativeExpiry has been set.\n     */\n    public isJoined(): boolean {\n        return this.membershipManager?.isJoined() ?? false;\n    }\n\n    /**\n     * Performs cleanup & removes timers for client shutdown\n     */\n    public async stop(): Promise<void> {\n        await this.membershipManager?.leave(1000);\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        this.roomSubset.off(RoomStateEvent.Members, this.onRoomMemberUpdate);\n        this.roomSubset.off(RoomStickyEventsEvent.Update, this.onStickyEventUpdate);\n    }\n\n    private reEmitter = new TypedReEmitter<\n        MatrixRTCSessionEvent | MembershipManagerEvent,\n        MatrixRTCSessionEventHandlerMap & MembershipManagerEventHandlerMap\n    >(this);\n\n    /**\n     * Announces this user and device as joined to the MatrixRTC session,\n     * and continues to update the membership event to keep it valid until\n     * leaveRoomSession() is called\n     * This will not subscribe to updates: remember to call subscribe() separately if\n     * desired.\n     * This method will return immediately and the session will be joined in the background.\n     * @param ownMembershipIdentity the identity of the user and device joining the session.\n     * This will be put into the content.member.\n     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.\n     * If multiSfuFocus is set, this is only needed if this client wants to publish to multiple transports simultaneously.\n     * @param multiSfuFocus the active focus to use in the joined RTC membership event. Setting this implies the\n     * membership manager will operate in a multi-SFU connection mode. If `undefined`, an `oldest_membership`\n     * transport selection will be used instead.\n     * @param joinConfig - Additional configuration for the joined session.\n     */\n    public joinRTCSession(\n        ownMembershipIdentity: CallMembershipIdentityParts,\n        fociPreferred: Transport[],\n        multiSfuFocus?: Transport,\n        joinConfig?: JoinSessionConfig,\n    ): void {\n        if (this.isJoined()) {\n            this.logger.info(`Already joined to session in room ${this.roomSubset.roomId}: ignoring join call`);\n            return;\n        } else {\n            // Create MembershipManager and pass the RTCSession logger (with room id info)\n            this.membershipManager = joinConfig?.unstableSendStickyEvents\n                ? new StickyEventMembershipManager(\n                      joinConfig,\n                      this.roomSubset,\n                      this.client,\n                      this.slotDescription,\n                      ownMembershipIdentity.memberId,\n                      this.logger,\n                  )\n                : new MembershipManager(joinConfig, this.roomSubset, this.client, this.slotDescription, this.logger);\n\n            this.reEmitter.reEmit(this.membershipManager!, [\n                MembershipManagerEvent.ProbablyLeft,\n                MembershipManagerEvent.StatusChanged,\n                MembershipManagerEvent.DelayIdChanged,\n            ]);\n            // Create Encryption manager\n            let transport;\n            if (joinConfig?.useExperimentalToDeviceTransport) {\n                this.logger.info(\"Using experimental to-device transport for encryption keys\");\n                this.logger.info(\"Using to-device with room fallback transport for encryption keys\");\n                const [room, client, statistics] = [this.roomSubset, this.client, this.statistics];\n                const transport = new ToDeviceKeyTransport(ownMembershipIdentity, room.roomId, client, statistics);\n                this.encryptionManager = new RTCEncryptionManager(\n                    ownMembershipIdentity,\n                    () => this.memberships,\n                    transport,\n                    this.statistics,\n                    (\n                        keyBin: Uint8Array<ArrayBuffer>,\n                        encryptionKeyIndex: number,\n                        membership: CallMembershipIdentityParts,\n                        rtcBackendIdentity: string,\n                    ) => {\n                        this.emit(\n                            MatrixRTCSessionEvent.EncryptionKeyChanged,\n                            keyBin,\n                            encryptionKeyIndex,\n                            membership,\n                            rtcBackendIdentity,\n                        );\n                    },\n                    this.logger,\n                );\n            } else {\n                // TODO REMOVE ME!\n                transport = new RoomKeyTransport(this.roomSubset, this.client, this.statistics);\n                this.encryptionManager = new EncryptionManager(\n                    ownMembershipIdentity,\n                    () => this.memberships,\n                    transport,\n                    this.statistics,\n                    (\n                        keyBin: Uint8Array<ArrayBuffer>,\n                        encryptionKeyIndex: number,\n                        membership: CallMembershipIdentityParts,\n                        rtcBackendIdentity: string,\n                    ) => {\n                        this.emit(\n                            MatrixRTCSessionEvent.EncryptionKeyChanged,\n                            keyBin,\n                            encryptionKeyIndex,\n                            membership,\n                            rtcBackendIdentity,\n                        );\n                    },\n                );\n            }\n        }\n\n        this.joinConfig = joinConfig;\n        this.pendingNotificationToSend = this.joinConfig?.notificationType;\n\n        // Join!\n        this.membershipManager!.join(fociPreferred, multiSfuFocus, (e) => {\n            this.logger.error(\"MembershipManager encountered an unrecoverable error: \", e);\n            this.emit(MatrixRTCSessionEvent.MembershipManagerError, e);\n            this.emit(MatrixRTCSessionEvent.JoinStateChanged, this.isJoined());\n        });\n        this.encryptionManager!.join(joinConfig);\n\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, true);\n    }\n\n    /**\n     *\n     * @param fociPreferred\n     * @param multiSfuFocus\n     * @param joinConfig\n     * @deprecated use the joinRTCSession method instead\n     */\n    public joinRoomSession(\n        fociPreferred: Transport[],\n        multiSfuFocus?: Transport,\n        joinConfig?: JoinSessionConfig,\n    ): void {\n        const [userId, deviceId] = [this.client.getUserId()!, this.client.getDeviceId()!];\n        // TODO this wants to become a UUID\n        const memberId = `${userId}:${deviceId}`;\n        this.joinRTCSession({ userId, deviceId, memberId }, fociPreferred, multiSfuFocus, joinConfig);\n    }\n\n    /**\n     * Announces this user and device as having left the MatrixRTC session\n     * and stops scheduled updates.\n     * This will not unsubscribe from updates: remember to call unsubscribe() separately if\n     * desired.\n     * The membership update required to leave the session will retry if it fails.\n     * Without network connection the promise will never resolve.\n     * A timeout can be provided so that there is a guarantee for the promise to resolve.\n     * @returns Whether the membership update was attempted and did not time out.\n     */\n    public async leaveRoomSession(timeout: number | undefined = undefined): Promise<boolean> {\n        if (!this.isJoined()) {\n            this.logger.info(`Not joined to session in room ${this.roomSubset.roomId}: ignoring leave call`);\n            return false;\n        }\n\n        this.logger.info(`Leaving call session in room ${this.roomSubset.roomId}`);\n\n        this.encryptionManager!.leave();\n\n        const leavePromise = this.membershipManager!.leave(timeout);\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, false);\n\n        return await leavePromise;\n    }\n    /**\n     * This returns the focus in use by the oldest membership.\n     * Do not use since this might be just the focus for the oldest membership. others might use a different focus.\n     * @deprecated use `member.getTransport(session.getOldestMembership())` instead for the specific member you want to get the focus for.\n     */\n    public getFocusInUse(): Transport | undefined {\n        const oldestMembership = this.getOldestMembership();\n        return oldestMembership?.getTransport(oldestMembership);\n    }\n\n    /**\n     * The used focusActive of the oldest membership (to find out the selection type multi-sfu or oldest membership active focus)\n     * @deprecated does not work with m.rtc.member. Do not rely on it.\n     */\n    public getActiveFocus(): Transport | undefined {\n        return this.getOldestMembership()?.getFocusActive();\n    }\n    public getOldestMembership(): CallMembership | undefined {\n        return this.memberships[0];\n    }\n\n    /**\n     * Get the call intent for the current call, based on what members are advertising. If one or more\n     * members disagree on the current call intent, or nobody specifies one then `undefined` is returned.\n     *\n     * If all members that specify a call intent agree, that value is returned.\n     * @returns A call intent, or `undefined` if no consensus or not given.\n     */\n    public getConsensusCallIntent(): RTCCallIntent | undefined {\n        const getFirstCallIntent = this.memberships.find((m) => !!m.callIntent)?.callIntent;\n        if (!getFirstCallIntent) {\n            return undefined;\n        }\n        if (this.memberships.every((m) => !m.callIntent || m.callIntent === getFirstCallIntent)) {\n            return getFirstCallIntent;\n        }\n        return undefined;\n    }\n\n    public async updateCallIntent(callIntent: RTCCallIntent): Promise<void> {\n        const myMembership = this.membershipManager?.ownMembership;\n        if (!myMembership) {\n            throw Error(\"Not connected yet\");\n        }\n        await this.membershipManager?.updateCallIntent(callIntent);\n    }\n\n    /**\n     * Re-emit an EncryptionKeyChanged event for each tracked encryption key. This can be used to export\n     * the keys.\n     */\n    public reemitEncryptionKeys(): void {\n        this.encryptionManager?.getEncryptionKeys().forEach((keyRing, key) => {\n            keyRing.forEach((keyInfo) => {\n                this.emit(\n                    MatrixRTCSessionEvent.EncryptionKeyChanged,\n                    keyInfo.key,\n                    keyInfo.keyIndex,\n                    keyInfo.membership,\n                    keyInfo.rtcBackendIdentity,\n                );\n            });\n        });\n    }\n\n    /**\n     * Sets a timer for the soonest membership expiry\n     */\n    private setExpiryTimer(): void {\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        let soonestExpiry;\n        for (const membership of this.memberships) {\n            const thisExpiry = membership.getMsUntilExpiry();\n            // If getMsUntilExpiry is undefined we have a MSC4143 (MatrixRTC) compliant event - it never expires\n            // but will be reliably resent on disconnect.\n            if (thisExpiry !== undefined && (soonestExpiry === undefined || thisExpiry < soonestExpiry)) {\n                soonestExpiry = thisExpiry;\n            }\n        }\n\n        if (soonestExpiry != undefined) {\n            this.expiryTimeout = setTimeout(this.ensureRecalculateSessionMembers.bind(this), soonestExpiry);\n        }\n    }\n\n    /**\n     * Sends notification events to indiciate the call has started.\n     * Note: This does not return a promise, instead scheduling the notification events to be sent.\n     * @param parentEventId Event id linking to your RTC call membership event.\n     * @param notificationType The type of notification to send\n     * @param callIntent The type of call this is (e.g. \"audio\").\n     */\n    private sendCallNotify(\n        parentEventId: string,\n        notificationType: RTCNotificationType,\n        callIntent?: RTCCallIntent,\n    ): void {\n        const sendNotificationEvent = async (): Promise<{\n            response: ISendEventResponse;\n            content: IRTCNotificationContent;\n        }> => {\n            const content: IRTCNotificationContent = {\n                \"m.mentions\": { user_ids: [], room: true },\n                \"notification_type\": notificationType,\n                \"m.relates_to\": {\n                    event_id: parentEventId,\n                    rel_type: RelationType.Reference,\n                },\n                \"sender_ts\": Date.now(),\n                \"lifetime\": 30_000, // 30 seconds\n            };\n            if (callIntent) {\n                content[\"m.call.intent\"] = callIntent;\n            }\n            const response = await this.client.sendEvent(this.roomSubset.roomId, EventType.RTCNotification, content);\n            return { response, content };\n        };\n\n        void sendNotificationEvent()\n            .then((notification) => {\n                // Join event_id and origin event content\n                const newResult = { ...notification.response, ...notification.content };\n                this.emit(MatrixRTCSessionEvent.DidSendCallNotification, newResult);\n            })\n            .catch(([errorLegacy, errorNew]) =>\n                this.logger.error(\"Failed to send call notification\", errorLegacy, errorNew),\n            );\n    }\n\n    /**\n     * Call this when the Matrix room members have changed.\n     */\n    private readonly onRoomMemberUpdate = (): void => {\n        this.ensureRecalculateSessionMembers();\n    };\n\n    /**\n     * Call this when a sticky event update has occured.\n     */\n    private readonly onStickyEventUpdate: RoomStickyEventsMap[RoomStickyEventsEvent.Update] = (\n        added,\n        updated,\n        removed,\n    ): void => {\n        if (\n            [...added, ...removed, ...updated.flatMap((v) => [v.current, v.previous])].some(\n                (e) => e.getType() === EventType.RTCMembership,\n            )\n        ) {\n            this.ensureRecalculateSessionMembers();\n        }\n    };\n\n    /**\n     * Call this when something changed that may impacts the current MatrixRTC members in this session.\n     */\n    // We allow this name schema since this function should only be used for testing purposes.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public _onRTCSessionMemberUpdate = async (): Promise<void> => {\n        await this.recalculateSessionMembers();\n    };\n\n    // helper variables to make sure we do not have parallel running recalculations.\n\n    private recalculateSessionMembersDirty = false;\n    private recalculateSessionMembersPromise: Promise<void> | undefined = undefined;\n\n    private ensureRecalculateSessionMembers(): void {\n        if (this.recalculateSessionMembersPromise === undefined) {\n            this.recalculateSessionMembersPromise = this.recalculateSessionMembers().then(() => {\n                this.recalculateSessionMembersPromise = undefined;\n                if (this.recalculateSessionMembersDirty) {\n                    this.ensureRecalculateSessionMembers();\n                    this.recalculateSessionMembersDirty = false;\n                }\n            });\n        } else {\n            this.recalculateSessionMembersDirty = true;\n        }\n    }\n\n    /**\n     * Call this when anything that could impact rtc memberships has changed: Room Members or RTC members.\n     *\n     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.\n     *\n     * This function should be called when the room members or call memberships might have changed.\n     */\n    private readonly recalculateSessionMembers = async (): Promise<void> => {\n        const oldMemberships = this.memberships;\n\n        this.memberships = await MatrixRTCSession.sessionMembershipsForSlot(\n            this.room,\n            slotDescriptionToId(this.slotDescription),\n            this.calculateMembershipsOpts,\n        );\n\n        const changed =\n            oldMemberships.length != this.memberships.length ||\n            oldMemberships.some((m, i) => !CallMembership.equal(m, this.memberships[i]));\n\n        if (changed) {\n            this.logger.info(\n                `Memberships for call in room ${this.roomSubset.roomId} have changed: emitting (${this.memberships.length} members)`,\n            );\n            logDurationSync(this.logger, \"emit MatrixRTCSessionEvent.MembershipsChanged\", () => {\n                this.emit(MatrixRTCSessionEvent.MembershipsChanged, oldMemberships, this.memberships);\n            });\n\n            void this.membershipManager?.onRTCSessionMemberUpdate(this.memberships);\n            // The `ownMembership` will be set when calling `onRTCSessionMemberUpdate`.\n            const ownMembership = this.membershipManager?.ownMembership;\n            if (this.pendingNotificationToSend && ownMembership && oldMemberships.length === 0) {\n                // If we're the first member in the call, we're responsible for\n                // sending the notification event\n                if (ownMembership.eventId && this.joinConfig?.notificationType) {\n                    this.sendCallNotify(\n                        ownMembership.eventId,\n                        this.joinConfig.notificationType,\n                        ownMembership.callIntent,\n                    );\n                } else {\n                    this.logger.warn(\"Own membership eventId is undefined, cannot send call notification\");\n                }\n            }\n            // If anyone else joins the session it is no longer our responsibility to send the notification.\n            // (If we were the joiner we already did sent the notification in the block above.)\n            if (this.memberships.length > 0) this.pendingNotificationToSend = undefined;\n        } else {\n            this.logger.debug(`No membership changes detected for room ${this.roomSubset.roomId}`);\n        }\n        // This also needs to be done if `changed` = false\n        // A member might have updated their fingerprint (created_ts)\n        void this.encryptionManager?.onMembershipsUpdate(oldMemberships);\n\n        this.setExpiryTimer();\n    };\n}\n\n/// Private helpers\nasync function computeBackendIdentityAndVerifyMemberEvents(\n    room: Pick<Room, \"hasMembershipState\">,\n    callMemberEvents: MatrixEvent[],\n    slotId: string,\n    logger: Logger,\n): Promise<CallMembership[]> {\n    const callMemberships: CallMembership[] = [];\n\n    for (const memberEvent of callMemberEvents) {\n        const content = memberEvent.getContent();\n\n        // Quick filter to avoid unneeded processing of invalid events or left events.\n        // A more thorough validation will be done later with CallMembership.membershipDataFromMatrixEvent.\n        if (!quickFilterNonRelevantContents(content, logger)) {\n            continue;\n        }\n\n        try {\n            const membershipData = CallMembership.membershipDataFromMatrixEvent(memberEvent);\n\n            const membership = new CallMembership(\n                memberEvent,\n                membershipData,\n                await CallMembership.computeRtcBackendIdentity(memberEvent, membershipData),\n                logger,\n            );\n\n            if (isValidMembership(membership, room, slotId, logger)) {\n                callMemberships.push(membership);\n            }\n        } catch (e) {\n            logger.warn(\"Couldn't construct call membership: \", e);\n        }\n    }\n\n    return callMemberships;\n}\n\nfunction quickFilterNonRelevantContents(content: IContent, logger: Logger): boolean {\n    // Ignore sticky keys for the count\n    const eventKeysCount = Object.keys(content).filter((k) => k !== \"msc4354_sticky_key\").length;\n    // Don't even bother about empty events (saves us from costly type/\"key in\" checks in bigger rooms)\n    if (eventKeysCount === 0) return false;\n\n    // We first decide if it's a MSC4143 event (per device state key)\n    if (eventKeysCount > 1 && \"application\" in content) {\n        // We have a MSC4143 event membership event with a proper joined content\n        return true;\n    } else if (eventKeysCount === 1 && \"memberships\" in content) {\n        logger.warn(`Legacy event found. Those are ignored, they do not contribute to the MatrixRTC session`);\n        return false;\n    } else {\n        // Invalid or left content\n        return false;\n    }\n}\n\nfunction isValidMembership(\n    membership: CallMembership,\n    room: Pick<Room, \"hasMembershipState\">,\n    slotId: string,\n    logger: Logger,\n): boolean {\n    if (membership.slotId !== slotId) {\n        logger.info(\n            `Ignoring membership of user ${membership.userId} for a different slot:  user: ${JSON.stringify(membership.slotDescription)}, slotId: ${slotId})`,\n        );\n        return false;\n    }\n\n    if (membership.isExpired()) {\n        logger.info(`Ignoring expired device membership ${membership.userId}/${membership.deviceId}`);\n        return false;\n    }\n\n    if (!room.hasMembershipState(membership.userId ?? \"\", KnownMembership.Join)) {\n        logger.info(`Ignoring membership of user ${membership.userId} who is not in the room.`);\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Collects the raw member events from room state and sticky store.\n */\nfunction collectMembersEvents(\n    room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"_unstable_getStickyEvents\">,\n    options: SessionMembershipsForSlotOpts,\n    logger: Logger,\n): MatrixEvent[] {\n    const { listenForStickyEvents, listenForMemberStateEvents } = options;\n    let callMemberEvents: MatrixEvent[] = [];\n    if (listenForStickyEvents) {\n        // prefill with sticky events\n        callMemberEvents = [...room._unstable_getStickyEvents()].filter((e) => e.getType() === EventType.RTCMembership);\n    }\n    if (listenForMemberStateEvents) {\n        const roomState = room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) {\n            logger.warn(\"Couldn't get state for room \" + room.roomId + \"using empty membership array\");\n            return [];\n        }\n        const callMemberStateEvents = roomState.getStateEvents(EventType.GroupCallMemberPrefix);\n        callMemberEvents = callMemberEvents.concat(\n            callMemberStateEvents.filter(\n                (callMemberStateEvent) =>\n                    !callMemberEvents.some(\n                        // only care about state events which have keys which we have not yet seen in the sticky events.\n                        // TODO: I believe this can discard a joined state event if there is a matching left sticky event.\n                        (stickyEvent) =>\n                            stickyEvent.getContent().msc4354_sticky_key === callMemberStateEvent.getStateKey(),\n                    ),\n            ),\n        );\n    }\n    return callMemberEvents;\n}\n"],"mappings":"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","ignoreList":[]}